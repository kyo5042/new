






































































































































































































// 6
import turtle

def draw_overlapping_squares_in_circle(num_squares, size, overlap, color_list):
    turtle.speed(100)
    turtle.hideturtle()
    angle = 360 / num_squares  # Angle between each square to create a circular pattern
    for i in range(num_squares):
        turtle.color(color_list[i % len(color_list)])
        turtle.begin_fill()
        for _ in range(4):
            turtle.forward(size)
            turtle.right(90)
        turtle.end_fill()
        turtle.penup()
        turtle.forward(size - overlap)
        turtle.right(angle)  # Rotate to the next position for the circular pattern
        turtle.pendown()
num_squares = 9
size = 50
overlap = 10
color_list = ["red", "blue", "green", "yellow", "orange", "purple", "pink", "cyan", "magenta", "black"]
draw_overlapping_squares_in_circle(num_squares, size, overlap, color_list)
turtle.done()


// 7
import turtle
import time
import random
# Set up the screen
wn = turtle.Screen()
wn.title("Snake Game")
wn.bgcolor("black")
wn.setup(width=600, height=600)
wn.tracer(0)
# Snake head
head = turtle.Turtle()
head.shape("square")
head.color("white")
head.penup()
head.direction = "stop"
# Food
food = turtle.Turtle()
food.shape("circle")
food.color("red")
food.penup()
food.goto(0, 100)
# Snake body segments
segments = []
# Score display
score = 0
score_display = turtle.Turtle()
score_display.color("white")
score_display.penup()
score_display.hideturtle()
score_display.goto(0, 260)
# Functions to change direction
def set_direction(new_direction):
    opposite_directions = {"up": "down", "down": "up", "left": "right", "right": "left"}
    if head.direction != opposite_directions.get(new_direction):
        head.direction = new_direction
# Move the snake
def move():
    if head.direction == "up":
        head.sety(head.ycor() + 20)
    elif head.direction == "down":
        head.sety(head.ycor() - 20)
    elif head.direction == "left":
        head.setx(head.xcor() - 20)
    elif head.direction == "right":
        head.setx(head.xcor() + 20)
# Keyboard bindings
wn.listen()
wn.onkeypress(lambda: set_direction("up"), "Up")
wn.onkeypress(lambda: set_direction("down"), "Down")
wn.onkeypress(lambda: set_direction("left"), "Left")
wn.onkeypress(lambda: set_direction("right"), "Right")
# Main game loop
while True:
    wn.update()
    # Check for collision with border
    if abs(head.xcor()) > 290 or abs(head.ycor()) > 290:
        break
    # Check for collision with food
    if head.distance(food) < 20:
        food.goto(random.randint(-290, 290), random.randint(-290, 290))
        # Add a new segment to the snake
        new_segment = turtle.Turtle()
        new_segment.shape("square")
        new_segment.color("grey")
        new_segment.penup()
        segments.append(new_segment)
        # Update score
        score += 10
        score_display.clear()
        score_display.write(f"Score: {score}", align="center", font=("Courier", 24, "normal"))
    # Move the snake segments
    for i in range(len(segments) - 1, 0, -1):
        segments[i].goto(segments[i - 1].pos())
    if segments:
        segments[0].goto(head.pos())
    move()
    # Check for collision with body
    if any(head.distance(segment) < 20 for segment in segments):
        break
    time.sleep(0.1)
# Display "Game Over" and the final score
score_display.clear()
score_display.goto(0, 0)
score_display.write("Game Over", align="center", font=("Courier", 36, "bold"))
score_display.goto(0, -40)
score_display.write(f"Score: {score}", align="center", font=("Courier", 18, "normal"))
wn.update()
# Delay before closing the game window
time.sleep(2)
wn.bye()
